= Projet Anagrammes
[Algorithmique Avancée] [L2 INFO] [2017 2018] [Nathanael Bayard]

// colors for monotype spans: fg = ba3925, bg = EEE

== Général

Tout a été traité et testé, et tout est fonctionnel.
Les réponses aux questions posées dans le PDF d'instruction pour les parties A et B peuvent être visualisées en exécutant les fichiers _A.py_ et _B.py_. Le code correspondant est à la fin de chaque fichier.


Stratégies de codage::
- *Programmation Dynamique* : construction et utilisation d'une structure de donnée pour faciliter et accélérer les calculs effectués.
- *Backtracking* pour la grande majorité des fonctions les plus importantes, simplement parce que cela semble la seule manière possible de procéder, ou en tout cas de loin la plus simple.
- Technique de recherche *Diviser Pour Régner* : utilisée pour optimiser encore plus l'accès à la structure du dictionnaire dans le cas le plus critique (cf <<Partie-B, Partie B>>).


Chiffres et Limitations::
Le programme nécessite environ 125Mo de mémoire vive pour la construction de la structure qui fait office de dictionnaire.
Celle-ci se construit en environ 5 à 8 secondes (dépend de la machine). Une fois cela fait, presque tous les calculs se font de manière instantanée :
- recherche des mots ayant le plus d'anagrammes (_A.py_)
- recherche des multi-anagrammes de `CAROLINE ET FLORIAN` pour n = 2 mots maximum, de `CHAMPOLLION` pour %n quelconque (_Tests_C.py_).

+
La recherche des mots ayant le plus de presque-anagrammes pour n = 1 lettre supplémentaire (_B.py_) demande elle beaucoup plus de temps : initialement, entre deux et trois minutes. Cependant, en optimisant la structure par le biais de tri systématique de certaines sous-listes du dictionnaire (_cf_ _Dico.py_ `Dico.optimize()`), ce qui permet une recherche en complexité logarithmique au lieu de séquentielle/linéaire, le temps pour ce calcul a pu être réduit à entre 50 et 80 secondes.

== Détails

=== Terminologie

Cette terminologie s'applique aussi en particulier aux noms de variables et aux commentaires dans le code.

Famille::
Pour une chaîne de caractère, sa *famille* désignera l'ensemble des mots du dictionnaire qui sont anagrammes de celle-ci.
En terme de type, pour simplifier les cartouches, j'ai utilisé l'alias `Family` en tant que synonyme pour le type `List String`, c'est-à-dire le type d'une liste de chaînes de caractère.

Signature::
Pour une chaîne de caractère `s`, sa *signature* correspond au résultat de `sorted(s)`. Pour une famille, sa *signature* est celle de n'importe quel mot contenu dans celle-ci. A toute signature donnée, correspond exactement 0 ou 1 famille du dictionnaire.

=== La classe `Dico`

Le coeur de l'efficacité de ce programme est basée sur l'idée d'indexer et de trier intelligemment l'intégralité du dictionnaire une fois pour toutes, afin que l'accès à la *famille* d'une quelconque chaîne de caractère se fasse aussi rapidement que possible. Dans le programme, le fichier du dictionnaire (_dico.txt_) est lu et son contenu est traité pour obtenir la variable globale `DICO`, qui est instance de la classe `Dico`. `DICO` possède un attribut `DICO.dico`, qui est une liste, et qui est le dictionnaire à proprement parler.

==== Structure interne de `DICO.dico`

`Dico.dico` contient toutes les familles d'anagrammes existantes du dictionnaire, déjà séparées dans des listes individuelles, et référencées par leur signature. C'est un tableau à deux dimensions, pour un accès aussi direct que possible aux familles recherchées. +

La première dimension correspond à la longueur des mots de la famille recherchée. La seconde dimension correspond à une formule calculée à partir des lettres des mots de la famille. A peu de chose près, elle correspond à la somme des lettres de n'importe quel mot de la famille, avec bien sûr A = 1, B = 2, etc. La fonction qui calcule cela s'appelle `wordSum()`. Donc, si l'on a une chaîne de caractère `s`, et l'on cherche ses anagrammes, la première chose à faire est de récupérer `tup := DICO.dico[len(s)][wordSum(s)]`.

`tup` est un tuple qui contient deux listes de même longueur. La seconde liste contient toutes les familles (c'est à dire les listes d'anagrammes) dont les mots ont la même longueur et la même somme que `s`. La première liste contient les *signatures* respectives des familles de la deuxième liste. Si l'on cherche la famille de `s`, il ne reste plus alors qu'à récupérer l'index de sa signature `sorted(s)` dans la première liste. Si cet index n'est pas `-1`, on récupère alors la famille correspondante à cet index dans le second élément de `tup`. Cette famille est alors directement l'ensemble des anagrammes de `s` dans le dictionnaire.

=== [[Partie-B]] Partie B

Comme dit précédemment, le calcul de la famille ayant le plus grand nombre de presque-anagrammes mettait très longtemps à l'origine. J'ai pu réduire ce temps de plus de la moitié en créant une méthode `Dico.optimize()`, qui, si appelée sur `DICO`, trie toutes les diverses listes de signatures (les premiers éléments des tuples mentionnées plus haut) dans un ordre alphabétique croissant, ce qui permet de remplacer une recherche séquentielle de la signature de la famille recherchée (_Tools.py_ `indexOf()`), par une recherche logarithmique, avec la stratégie de *Diviser Pour Régner* (_Tools.py_ `indexOf_div()`).

La méthode `Dico.optimize()` ne prend même pas 1 seconde pour effectuer ce tri, le gain est donc très important, cela dit vu qu'elle n'est pas nécessaire pour le reste des tests et des questions, elle n'est appelée sur `DICO` que dans `B.py` -- là où il y en avait vraiment besoin.

=== Partie C

==== Algorithme pour `multiAnagrams()`

Cette fonction est le moteur principal de `A1` et `A2`. Elle récupère tous les "multi-anagrammes" de exactement `n` mots de la chaîne donnée en entrée (sous la forme d'une liste de listes de `n` familles). Elle est écrite en backtracking, et c'est de loin la plus longue est compliquée.

Il est en effet difficile d'éviter de récupérer plusieurs fois les mêmes solutions. Le premier pas a été de faire en sorte que la longueur des mots soit toujours croissante en profondeur, puisque `[SEL, LE] == [LE, SEL]`. Mais ce fut loin d'être suffisant.

Par exemple, si deux familles `F` et `G` ont des signatures de même longueur, on risque d'avoir des doublons du type `[F G] == [G F]`. On gère ce problème en faisant en sorte que la signature des mots soit croissante (alphabétiquement parlant) en profondeur, dans le cas où deux signatures se suivent et sont de même longueur.

L'algorithme nécessite tant de paramètres (une dizaine), que j'ai préféré créer une classe `BTState` (pour _state of the backtracker_) pour contenir tous les paramètres nécessaires.

~~ Lister paramètres?
